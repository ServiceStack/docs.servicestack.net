---
title: ServiceStack v6.6
released: 2023-02-07
---

<div>
    <svg class="w-80 h-80 block mx-auto" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><path fill="#f5de19" d="M2 2h28v28H2z"/><path d="M20.809 23.875a2.866 2.866 0 0 0 2.6 1.6c1.09 0 1.787-.545 1.787-1.3c0-.9-.716-1.222-1.916-1.747l-.658-.282c-1.9-.809-3.16-1.822-3.16-3.964c0-1.973 1.5-3.476 3.853-3.476a3.889 3.889 0 0 1 3.742 2.107L25 18.128A1.789 1.789 0 0 0 23.311 17a1.145 1.145 0 0 0-1.259 1.128c0 .789.489 1.109 1.618 1.6l.658.282c2.236.959 3.5 1.936 3.5 4.133c0 2.369-1.861 3.667-4.36 3.667a5.055 5.055 0 0 1-4.795-2.691Zm-9.295.228c.413.733.789 1.353 1.693 1.353c.864 0 1.41-.338 1.41-1.653v-8.947h2.631v8.982c0 2.724-1.6 3.964-3.929 3.964a4.085 4.085 0 0 1-3.947-2.4Z"/></svg>
</div>

We're got a feature-packed JavaScript focus release that embraces [JavaScript modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) support in modern browsers to enable a simplified rapid development experience without the disadvantages that have plagued 
Single Page Apps (SPA) development up till now.

### JavaScript Modules

[JavaScript modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) have revolutionized the way we write and structure code in modern browsers which provide a number of advantages including better code organization and reuse, improved maintainability, and increased modularity and scalability which has seen it become a popular choice for building complex, scalable web applications. 

With modules, developers can create small, focused pieces of code that can be easily imported and used in other parts of their application without needing to rely on any complex tooling. This results in a cleaner, more organized codebase that is easier to maintain over time. 

## Modern Vue.js Tailwind .NET Apps

Our new templates builds upon JS Modules with a number of new integrated features to maximize productivity and performance for this revolutionary new approach to Web App development that offers new dramatically simplified and friction-free development experience without the need to rely on any heavy npm build tools - which we believe offers the best mix of productivity and simplicity available today.

Spearheaded by our exciting new **@servicestack/vue** [Vue.js Tailwind Components](/vue/), we've created a number of new Vue.js Tailwind project templates preconfigured with a minimal set of libraries to make you immediately productive out-of-the-box.

<div id="vue-templates" class="not-prose mt-12 flex flex-col items-center">
    <div class="flex">
        <svg class="w-24 h-24 mr-8" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><path fill="#41b883" d="M24.4 3.925H30l-14 24.15L2 3.925h10.71l3.29 5.6l3.22-5.6Z"/><path fill="#41b883" d="m2 3.925l14 24.15l14-24.15h-5.6L16 18.415L7.53 3.925Z"/><path fill="#35495e" d="M7.53 3.925L16 18.485l8.4-14.56h-5.18L16 9.525l-3.29-5.6Z"/></svg>
        <svg class="w-28 h-28" xmlns="http://www.w3.org/2000/svg" width="256" height="154" viewBox="0 0 256 154"><defs><linearGradient id="logosTailwindcssIcon0" x1="-2.778%" x2="100%" y1="32%" y2="67.556%"><stop offset="0%" stop-color="#2298BD"/><stop offset="100%" stop-color="#0ED7B5"/></linearGradient></defs><path fill="url(#logosTailwindcssIcon0)" d="M128 0C93.867 0 72.533 17.067 64 51.2C76.8 34.133 91.733 27.733 108.8 32c9.737 2.434 16.697 9.499 24.401 17.318C145.751 62.057 160.275 76.8 192 76.8c34.133 0 55.467-17.067 64-51.2c-12.8 17.067-27.733 23.467-44.8 19.2c-9.737-2.434-16.697-9.499-24.401-17.318C174.249 14.743 159.725 0 128 0ZM64 76.8C29.867 76.8 8.533 93.867 0 128c12.8-17.067 27.733-23.467 44.8-19.2c9.737 2.434 16.697 9.499 24.401 17.318C81.751 138.857 96.275 153.6 128 153.6c34.133 0 55.467-17.067 64-51.2c-12.8 17.067-27.733 23.467-44.8 19.2c-9.737-2.434-16.697-9.499-24.401-17.318C110.249 91.543 95.725 76.8 64 76.8Z"/></svg>
    </div>
</div>
<div class="not-prose relative bg-white dark:bg-black py-4">
  <div class="mx-auto max-w-md px-4 text-center sm:max-w-3xl sm:px-6 lg:max-w-7xl lg:px-8">
    <p class="mt-2 text-3xl font-extrabold tracking-tight text-gray-900 dark:text-gray-50 sm:text-4xl">Vue.js Tailwind Templates</p>
  </div>
</div>

<vue-tailwind-templates></vue-tailwind-templates>

## Vue.js Tailwind Live Demos

All Razor Pages and MVC templates utilize the JS Modules support in modern browsers to avoid any needing any npm build system, 
for access to more advanced npm library features and to learn about Jamstack CDN and SSG benefits checkout [Jamstack Templates docs](/templates/jamstack).

<div class="not-prose mt-8 grid grid-cols-2 gap-4">
    <a class="block group border hover:border-indigo-700" href="https://vue-mjs.web-templates.io">
        <img class="p-2" src="https://raw.githubusercontent.com/ServiceStack/Assets/master/csharp-templates/vue-mjs.png">
        <div class="bg-gray-50 text-gray-600 font-semibold group-hover:bg-indigo-700 group-hover:text-white text-center py-2">vue-mjs.web-templates.io</div>
    </a>
    <a class="block group border hover:border-indigo-700" href="https://razor.web-templates.io">
        <img class="p-2" src="https://raw.githubusercontent.com/ServiceStack/Assets/master/csharp-templates/razor.png">
        <div class="bg-gray-50 text-gray-600 font-semibold group-hover:bg-indigo-700 group-hover:text-white text-center py-2">razor.web-templates.io</div>
    </a>
    <a class="block group border hover:border-indigo-700" href="https://mvc.web-templates.io">
        <img class="p-2" src="https://raw.githubusercontent.com/ServiceStack/Assets/master/csharp-templates/mvc.png">
        <div class="bg-gray-50 text-gray-600 font-semibold group-hover:bg-indigo-700 group-hover:text-white text-center py-2">mvc.web-templates.io</div>
    </a>
    <a class="block group border hover:border-indigo-700" href="https://vue-vite.jamstacks.net">
        <img class="p-2 max-h-[301px]" src="https://raw.githubusercontent.com/ServiceStack/Assets/master/csharp-templates/vue-vite.png">
        <div class="bg-gray-50 text-gray-600 font-semibold group-hover:bg-indigo-700 group-hover:text-white text-center py-2">vue-vite.jamstacks.net</div>
    </a>
</div>

To help choosing which template to start with, here's a quick summary of their differences:

 - **vue-mjs** - Flagship Vue.mjs template complete with [OrmLite](/ormlite/), [AutoQuery](/autoquery/), [boosted htmx](https://htmx.org/attributes/hx-boost/) links & [static pre-rendered blogs](https://vue-mjs.web-templates.io/blog/prerendering)
 - **razor** - Simpler Razor Pages Template without a configured DB or static pre-rendered blogs
 - **mvc** - Want to use MVC Identity Auth and Entity Framework
 - **web-tailwind** - Empty tailwind template who don't want to use Razor Pages or MVC
 - **vue-vite** - Want to use TypeScript in a simpler JAMStack Vite SPA App
 - **vue-ssg** - Want to use TypeScript in an advanced JAMStack Vite SSG App

 For a more in-depth look we've created an overview covering the differences between the Razor Pages & MVC templates:

<div class="flex justify-center">
<lite-youtube class="w-full mx-4 my-4" width="560" height="315" videoid="SyppvQB7IPs" style="background-image: url('https://img.youtube.com/vi/SyppvQB7IPs/maxresdefault.jpg')"></lite-youtube>
</div>

### Vue.js Bootstrap Razor Pages Template

For devs preferring Bootstrap, we've also created a new Razor Pages template integrated with JS Modules:

<div class="flex justify-center">
    <svg class="my-8 w-24 h-24" xmlns="http://www.w3.org/2000/svg" width="256" height="204" viewBox="0 0 256 204"><path fill="#7E13F8" d="M53.172 0C38.565 0 27.756 12.785 28.24 26.65c.465 13.32-.139 30.573-4.482 44.642C19.402 85.402 12.034 94.34 0 95.488v12.956c12.034 1.148 19.402 10.086 23.758 24.197c4.343 14.069 4.947 31.32 4.482 44.641c-.484 13.863 10.325 26.65 24.934 26.65h149.673c14.608 0 25.414-12.785 24.93-26.65c-.464-13.32.139-30.572 4.482-44.641c4.359-14.11 11.707-23.05 23.741-24.197V95.488c-12.034-1.148-19.382-10.086-23.74-24.196c-4.344-14.067-4.947-31.321-4.483-44.642C228.261 12.787 217.455 0 202.847 0H53.17h.002ZM173.56 125.533c0 19.092-14.24 30.67-37.872 30.67h-40.23a4.339 4.339 0 0 1-4.338-4.339V52.068a4.339 4.339 0 0 1 4.339-4.34h39.999c19.705 0 32.637 10.675 32.637 27.063c0 11.503-8.7 21.801-19.783 23.604v.601c15.089 1.655 25.248 12.104 25.248 26.537Zm-42.26-64.05h-22.937v32.4h19.32c14.934 0 23.17-6.014 23.17-16.764c0-10.073-7.082-15.636-19.552-15.636Zm-22.937 45.256v35.705h23.782c15.548 0 23.786-6.239 23.786-17.965c0-11.728-8.467-17.742-24.786-17.742h-22.782v.002Z"/></svg>
</div>

<div class="not-prose flex justify-center">
    <a class="block max-w-xl group border hover:border-indigo-700" href="https://razor-pages.web-templates.io">
        <img class="p-2" src="https://raw.githubusercontent.com/ServiceStack/Assets/master/csharp-templates/razor-pages.png">
        <div class="bg-gray-50 text-gray-600 font-semibold group-hover:bg-indigo-700 group-hover:text-white text-center py-2">razor-pages.web-templates.io</div>
    </a>
</div>

Install with:

:::sh
x new razor-pages MyApp
:::

## JS Modules Quick Look

We'll take a quick glimpse on some of the power of JS Modules with the introduction of our new **JS Module ES6 class DTOs** feature, where you'll be able to walk up to any ServiceStack v6.6+ Web App, import some external modules independent from the rest of the page, then call end-to-end typed APIs without using any pre existing JS libraries or build tools in sight!

The Blazor Server live demo at [blazor.web-templates.io](https://blazor.web-templates.io) is a good one to try this on given it's built on an entirely different server rendered technology stack. To try it out press `F12` to open a dev console then paste in the sample code below:

```js
document.body.insertAdjacentHTML('beforeend',`<div style="position:fixed;right:1em;top:5em">
    <input type="text" id="txtName">
    <div id="result"></div>
</div>`)

const ServiceStack = await import('https://unpkg.com/@servicestack/client@2/dist/servicestack-client.mjs')
const dtos = await import('/types/mjs')
const { JsonServiceClient, on, $1 } = ServiceStack
const client = new JsonServiceClient()

on('#txtName', {
    async keyup(el) {
        const api = await client.api(new dtos.Hello({ name:el.target.value }))
        $1('#result').innerHTML = api.response.result
    }
})
```

After the browser asynchronously loads the modules you should see a working text input which calls its [Hello API](https://blazor.web-templates.io/ui/Hello) on each key press:

<a href="https://blazor.web-templates.io"><div class="my-8 mx-auto max-w-xl block flex justify-center shadow hover:shadow-lg rounded py-1"><img class="p-4" src="/img/pages/release-notes/v6.6/js-modules-dev-console.png"></div></a>

### Dynamically Loading Multiple JS Modules

Ok that's cool, but let's see how far we can go with it and introduce the new [Vue.js Tailwind Components](/vue/) into the mix to see how close we can get to recreating some of this Blazor Server App's functionality.

Lets head over to the Bookings page and Sign In:

<a class="block text-2xl text-center py-4 font-semibold" href="https://blazor.web-templates.io/secure/bookings" target="_blank">blazor.web-templates.io/secure/bookings</a>

Then press `F12` to open the dev console again to paste and run the code below:

```js
const im = document.createElement('script');
im.type = 'importmap';
im.textContent = JSON.stringify({
    "imports": {
        "vue": "https://unpkg.com/vue@3/dist/vue.esm-browser.prod.js",
        "@servicestack/client": "https://unpkg.com/@servicestack/client@2/dist/servicestack-client.min.mjs",
        "@servicestack/vue": "https://unpkg.com/@servicestack/vue@3/dist/servicestack-vue.min.mjs"
    }
});
document.body.appendChild(im)

const Vue = await import('vue')
const ServiceStack = await import('@servicestack/client')
const ServiceStackVue = await import('@servicestack/vue')
const dtos = await import('/types/mjs')

const BookingsApp = {
  template:`
  <div class="sm:max-w-fit p-4 m-4">
    <h3 class="ml-4 text-center text-2xl font-medium">Vue.js Bookings</h3>
    <AutoCreateForm v-if="create" type="CreateBooking" @done="done" @save="done" />
    <AutoEditForm v-else-if="edit" type="UpdateBooking" deleteType="DeleteBooking" v-model="edit" 
      @done="done" @save="done" @delete="done" />
    <OutlineButton @click="reset({ create:true })">New Booking</OutlineButton>
    <DataGrid :items="bookings" type="Booking" 
      selected-columns="id,name,roomType,roomNumber,cost,bookingStartDate,bookingEndDate,couponId" 
      :header-titles="{roomNumber:'Room No',bookingStartDate:'Start Date',bookingEndDate:'End Date',couponId:'Voucher'}"
      :visible-from="{ name:'xl', bookingStartDate:'sm', bookingEndDate:'xl', couponId:'xl' }"
      @row-selected="editId = editId == $event.id ? null : $event.id" :is-selected="row => editId == row.id" />
  </div>`,
  setup(props) {
    const { ref, onMounted, watch } = Vue
    const { useClient, useAuth, useFormatters } = ServiceStackVue
    const { QueryBookings } = dtos

    const create = ref(false)
    const editId = ref()
    const edit = ref()
    const bookings = ref([])

    const client = useClient()
    const { currency } = useFormatters()
    
    async function refresh() {
      const api = await client.api(new QueryBookings())
      if (api.succeeded) {
        bookings.value = api.response.results || []
      }
    }
    onMounted(refresh)

    function reset(args={}) {
      create.value = args.create ?? false
      editId.value = args.editId ?? undefined
    }

    function done() {
      refresh()
      reset()
    }
    
    watch(editId, async () => {
      if (editId.value) {
        const api = await client.api(new QueryBookings({ id: editId.value }))
        if (api.succeeded) {
          edit.value = api.response.results[0]
          return
        }
      }
      edit.value = null
    })
    
    return { create, editId, edit, bookings, reset, done, currency }
  }
}

const app = Vue.createApp(BookingsApp)
app.provide('client', new ServiceStack.JsonServiceClient())
app.use(ServiceStackVue.default)
await ServiceStackVue.useMetadata().loadMetadata()

document.querySelector('main').insertAdjacentHTML('beforeend',`<div id="app"></div>`)
app.mount('#app')
```

Give it a moment to load all the modules and you should see a shiny new freshly baked Vue.js data grid infiltrating the Blazor Server App!

<div class="mb-16"><a href="https://blazor.web-templates.io/secure/bookings" target="_blank"><img class="w-[1330px] -ml-40" style="max-width:none" src="/img/pages/release-notes/v6.6/js-modules-bookings-crud.png"></a></div>

This isn't just cosmetic, it's a full CRUD Bookings App with responsive formatted [DataGrid](/vue/datagrid) columns, 
API-enabled [AutoForm](/vue/autoform) components powered by the App's [API Metadata](/vue/use-metadata) 
with populated Enum drop downs, optimal number, date & checkbox inputs and validation binding:


<div class="mt-16"><a href="https://blazor.web-templates.io/secure/bookings" target="_blank"><img class="my-8" style="max-width:none" src="/img/pages/release-notes/v6.6/js-modules-bookings-crud-update.png"></a></div>

It doesn't have all the features of the [Blazor AutoQueryGrid](https://blazor-gallery.servicestack.net/gallery/autoquerygrid) component yet, 
but with a splash of code to load a few modules and create a custom Vue 3 reactive component, we can get most of the functionality
without any of the heavy build tools complexity of a Blazor App or traditional npm SPA App and their matrix of dependencies.

### Best mix of Productivity vs Simplicity

From a pragmatic standpoint we believe JS Modules offers the best mix of productivity and simplicity, that can be progressively added
to enhance server rendered Razor Pages with interactive reactive components without imposing its technical choices and bloating its 
other pages which are free to choose whichever libraries are best to implement its features.

### Various WebApp DTO Options

The only requirement for this to work is that the libraries are written as [JS Modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) which is a popular build target, but given we want to enable a typed and build-tools free future we've added a new **.mjs** [Add ServiceStack Reference](/add-servicestack-reference) endpoint at **/types/mjs** to return your APIs DTOs in annotated ES6 class JS Module. To see where they benefit, lets quickly go over the existing options:

### Common.js ES3 DTOs

Our existing [JavaScript Add ServiceStack Reference](/javascript-add-servicestack-reference) support returns your API DTOs in **ES3** Common JS format, i.e. the default Target of TypeScript, in order to generate JS that's also compatible with older, out-dated browsers from 1999, that looks like:

```js
var Hello = /** @class */ (function () {
    function Hello(init) {
        Object.assign(this, init);
    }
    Hello.prototype.getTypeName = function () { return 'Hello'; };
    Hello.prototype.getMethod = function () { return 'POST'; };
    Hello.prototype.createResponse = function () { return new HelloResponse(); };
    return Hello;
}());
exports.Hello = Hello;

var HelloResponse = /** @class */ (function () {
    function HelloResponse(init) {
        Object.assign(this, init);
    }
    return HelloResponse;
}());
exports.HelloResponse = HelloResponse;
```

This does enable a similar build-free dev experience which lets you easily include your APIs DTOs in a page along with an 
[Embedded UMD @servicestack/client](/servicestack-client-umd) to start making API calls, e.g:

```html
<script src="/js/require.js"></script>
<script src="/js/servicestack-client.js"></script>
<script src="/types/js"></script>
<script>
var { JsonServiceClient, Hello } = exports

var client = new JsonServiceClient()
function callHello(name) {
    client.get(new Hello({ name }))
        .then(function(r) {
            document.getElementById('result').innerHTML = r.result
        });
}
</script>
```

But it offers no type-checking or intelli-sense assistance during development, luckily we can [enable static analysis](/servicestack-client-umd#rich-intelli-sense-support) support by including [TypeScript dtos.ts](/typescript-add-servicestack-reference) in the same project which smart IDEs like [JetBrains Rider](https://www.jetbrains.com/rider/) will find to light up assistance.

### TypeScript DTOs

The TypeScript DTOs capture the most Type Information about your API DTOs in generic TypeScript classes:

```ts
// @Route("/hello")
// @Route("/hello/{Name}")
export class Hello implements IReturn<HelloResponse>
{
    public name?: string;

    public constructor(init?: Partial<Hello>) { (Object as any).assign(this, init); }
    public getTypeName() { return 'Hello'; }
    public getMethod() { return 'POST'; }
    public createResponse() { return new HelloResponse(); }
}

export class HelloResponse
{
    public result: string;

    public constructor(init?: Partial<HelloResponse>) { (Object as any).assign(this, init); }
}
```

Which is still the best option to use in our [JAMStack TypeScript templates](/templates/jamstack) where the DTOs integrate with the rest of your App's TypeScript code-base and its npm build tools takes care to transform it into its configured downlevel JS target bundles.

The primary issue being that Browsers can't run them natively, so developing in TypeScript typically requires an npm build system to do the transformation which adds complexity and results in slower iterative dev cycles.

### JS Module ES6 class DTOs

The new ES6 classes combines the best of both worlds to enable a productive type-safe development model during development but can also be referenced as-is in JS Module scripts and run natively in browsers without any build tools!

To achieve this the ES6 classes are annotated with [JSDoc](https://jsdoc.app) type hints in comments which enjoys broad support in IDEs and
tools like TypeScript where it can be used to [provide type information in JavaScript files](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html), which looks like:

```js
export class Hello {
    /** @param {{name?:string}} [init] */
    constructor(init) { Object.assign(this, init) }
    /** @type {string} */
    name;
    getTypeName() { return 'Hello' }
    getMethod() { return 'GET' }
    createResponse() { return new HelloResponse() }
}

export class HelloResponse {
    /** @param {{result?:string,responseStatus?:ResponseStatus}} [init] */
    constructor(init) { Object.assign(this, init) }
    /** @type {string} */
    result;
    /** @type {?ResponseStatus} */
    responseStatus;
}
```

Which our JS Apps can immediately use by referencing the **/types/mjs** endpoint directly:

```js
import { Hello } from '/types/mjs'
const api = await client.api(new Hello({ name }))
```

That for better IDE intelli-sense during development, we can save to disk with:

:::sh
npm run dtos
:::

Where it enables IDE static analysis when calling Typed APIs from JavaScript:

```js
import { Hello } from '/mjs/dtos.mjs'
```

![](/img/pages/release-notes/v6.6/mjs-intellisense.png)

### .mjs Add ServiceStack Reference

The new JS Modules DTOs is now a first-class [Add ServiceStack Reference language](https://servicestack.net/service-reference) supported language complete with IDE integration in the latest VS .NET and JetBrains IDEs extensions:

<div class="not-prose mt-8 grid grid-cols-2 gap-4 ">
    <a class="block bg-neutral-900 group border border-neutral-800 hover:border-indigo-700" href="https://marketplace.visualstudio.com/items?itemName=Mythz.ServiceStackVS">
        <div class="bg-neutral-700 text-white font-semibold group-hover:bg-indigo-700 text-center py-2">VS.NET</div>
        <img class="" src="/img/pages/servicestack-reference/mjs-update-reference-vs.png">
    </a>
    <a class="block bg-neutral-900 group border border-neutral-800 hover:border-indigo-700" href="https://plugins.jetbrains.com/plugin/17295-servicestack">
        <div class="bg-neutral-700 text-white font-semibold group-hover:bg-indigo-700 text-center py-2">JetBrains Rider</div>
        <img class="" src="/img/pages/servicestack-reference/mjs-update-reference-rider.png">
    </a>
</div>

Including support in the latest [dotnet tool](/dotnet-tool) for creating new **.mjs** Add ServiceStack References:

```bash
$ x mjs https://localhost:5001
```

And updating them:

```bash
x mjs
```

But the best thing about JS Module DTOs is using them in the exciting new node_modules free world enabled in the new Vue.js templates!

## Multi Page Apps

<div id="multi-page-apps" data-hide="h2#multi-page-apps" data-id="MultiPageApps">
<div class="relative bg-white dark:bg-black py-4"><div class="mx-auto max-w-md px-4 text-center sm:max-w-3xl sm:px-6 lg:max-w-7xl lg:px-8"><p class="mt-2 text-3xl font-extrabold tracking-tight text-gray-900 dark:text-gray-50 sm:text-4xl">Back to Multi Page Apps</p><p class="mx-auto mt-5 max-w-prose text-xl text-gray-500"> Discover the productive build tools free world of modern JS Module MPAs</p></div></div>
<div class="flex justify-around">
    <svg class="w-40 h-40 text-slate-500" xmlns="http://www.w3.org/2000/svg" width="36" height="36" viewBox="0 0 36 36"><path fill="currentColor" d="M6 9h2v2H6z" class="clr-i-outline clr-i-outline-path-1"/><path fill="currentColor" d="M10 9h14v2H10z" class="clr-i-outline clr-i-outline-path-2"/><path fill="currentColor" d="M6 17h2v2H6z" class="clr-i-outline clr-i-outline-path-3"/><path fill="currentColor" d="M10 17h14v2H10z" class="clr-i-outline clr-i-outline-path-4"/><path fill="currentColor" d="M32 5H4a2 2 0 0 0-2 2v22a2 2 0 0 0 2 2h28a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2ZM4 7h28v6H4Zm0 8h28v6H4Zm0 14v-6h28v6Z" class="clr-i-outline clr-i-outline-path-5"/><path fill="currentColor" d="M6 25h2v2H6z" class="clr-i-outline clr-i-outline-path-6"/><path fill="currentColor" d="M10 25h14v2H10z" class="clr-i-outline clr-i-outline-path-7"/><path fill="none" d="M0 0h36v36H0z"/></svg>
    <svg class="w-40 h-40 text-slate-500" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="currentColor" d="M19 13H5v-2h14v2Z"/></svg>
    <svg class="w-40 h-40 text-slate-500" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="currentColor" d="M15 15H9v-1h6v1m0 1H9v1h6v-1m0 2H9v1h6v-1m8-4.5c0 1.25-.44 2.31-1.31 3.19c-.88.87-1.94 1.31-3.19 1.31H18v4H6v-4.05c-1.3-.1-2.43-.59-3.39-1.52C1.54 15.38 1 14.09 1 12.58c0-1.3.39-2.46 1.17-3.48S4 7.43 5.25 7.15c.42-1.53 1.25-2.77 2.5-3.72S10.42 2 12 2c1.95 0 3.6.68 4.96 2.04C18.32 5.4 19 7.05 19 9c1.15.13 2.1.63 2.86 1.5c.76.85 1.14 1.85 1.14 3M6 15.95V11h11V9c0-1.38-.5-2.56-1.46-3.54C14.56 4.5 13.38 4 12 4s-2.56.5-3.54 1.46C7.5 6.44 7 7.62 7 9h-.5c-.97 0-1.79.34-2.47 1.03c-.69.68-1.03 1.5-1.03 2.47s.34 1.79 1.03 2.5c.56.54 1.22.85 1.97.95M16 13H8v7h8v-7m5 .5c0-.7-.24-1.29-.73-1.77S19.2 11 18.5 11H18v5h.5c.7 0 1.29-.24 1.77-.72S21 14.2 21 13.5Z"/></svg>
    <svg class="w-40 h-40 text-slate-500" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="currentColor" d="M19 13H5v-2h14v2Z"/></svg>
    <svg class="mt-4 w-36 h-36 text-slate-500" xmlns="http://www.w3.org/2000/svg" width="512" height="472" viewBox="0 0 512 472"><path fill="currentColor" d="M469 3H43Q25 3 12.5 15.5T0 45v363q0 21 21 21h470q21 0 21-21V45q0-17-12.5-29.5T469 3zm0 384H43V152h426v235zm0-278H43V45h426v64zm-277 86H85v149h107V195zm-43 106h-21v-64h21v64zm86-106h192v42H235v-42zm0 85h149v43H235v-43z"/></svg>
</div></div>

<svg data-id="icon-js" class="sm:float-left mr-4 w-24 h-24" style="margin-top:0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 630 630"><rect width="630" height="630" fill="#f7df1e"/><path d="m423.2 492.19c12.69 20.72 29.2 35.95 58.4 35.95 24.53 0 40.2-12.26 40.2-29.2 0-20.3-16.1-27.49-43.1-39.3l-14.8-6.35c-42.72-18.2-71.1-41-71.1-89.2 0-44.4 33.83-78.2 86.7-78.2 37.64 0 64.7 13.1 84.2 47.4l-46.1 29.6c-10.15-18.2-21.1-25.37-38.1-25.37-17.34 0-28.33 11-28.33 25.37 0 17.76 11 24.95 36.4 35.95l14.8 6.34c50.3 21.57 78.7 43.56 78.7 93 0 53.3-41.87 82.5-98.1 82.5-54.98 0-90.5-26.2-107.88-60.54zm-209.13 5.13c9.3 16.5 17.76 30.45 38.1 30.45 19.45 0 31.72-7.61 31.72-37.2v-201.3h59.2v202.1c0 61.3-35.94 89.2-88.4 89.2-47.4 0-74.85-24.53-88.81-54.075z"/></svg>

JavaScript has progressed significantly in recent times where many of the tooling & language enhancements
that we used to rely on external tools for is now available in modern browsers alleviating the need for
complex tooling and npm dependencies that have historically plagued modern web development.

The good news is that the complex npm tooling that was previously considered mandatory in modern JavaScript App 
development can be considered optional as we can now utilize modern browser features like 
[async/await](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function),
[JavaScript Modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules), 
[dynamic imports](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import), 
[import maps](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script/type/importmap)
and [modern language features](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide) for a 
sophisticated development workflow without the need for any npm build tools. 

### Bringing Simplicity Back

The new Razor Vue.mjs templates focuses on simplicity and eschews many aspects that has complicated modern JavaScript development, specifically:

 - No npm **node_modules** or build tools
 - No client side routing
 - No heavy client state

Effectively abandoning the traditional SPA approach in lieu of a simpler [MPA](https://docs.astro.build/en/concepts/mpa-vs-spa/) 
development model using Razor Pages for Server Rendered content with any interactive UIs progressively enhanced with JavaScript.

#### Freedom to use any JS library

Avoiding the SPA route ends up affording more flexibility on which JS libraries each page can use as without heavy bundled JS
blobs of all JS used in the entire App, it's free to only load the required JS each page needs to best implement its 
required functionality, which can be any JS library, preferably utilizing ESM builds that can be referenced from a 
[JavaScript Module](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules), taking advantage of the module system
native to modern browsers able to efficiently download the declarative matrix of dependencies each script needs. 

### Best libraries for progressive Multi Page Apps

By default the Razor Vue.js templates includes a collection of libraries we believe offers the best modern development experience in Progressive
MPA Web Apps, specifically:

<div data-id="icon-tailwind">
    <svg class="mx-auto block w-20 h-20" xmlns="http://www.w3.org/2000/svg" width="256" height="154" viewBox="0 0 256 154"><defs><linearGradient id="logosTailwindcssIcon0" x1="-2.778%" x2="100%" y1="32%" y2="67.556%"><stop offset="0%" stop-color="#2298BD"/><stop offset="100%" stop-color="#0ED7B5"/></linearGradient></defs><path fill="url(#logosTailwindcssIcon0)" d="M128 0C93.867 0 72.533 17.067 64 51.2C76.8 34.133 91.733 27.733 108.8 32c9.737 2.434 16.697 9.499 24.401 17.318C145.751 62.057 160.275 76.8 192 76.8c34.133 0 55.467-17.067 64-51.2c-12.8 17.067-27.733 23.467-44.8 19.2c-9.737-2.434-16.697-9.499-24.401-17.318C174.249 14.743 159.725 0 128 0ZM64 76.8C29.867 76.8 8.533 93.867 0 128c12.8-17.067 27.733-23.467 44.8-19.2c9.737 2.434 16.697 9.499 24.401 17.318C81.751 138.857 96.275 153.6 128 153.6c34.133 0 55.467-17.067 64-51.2c-12.8 17.067-27.733 23.467-44.8 19.2c-9.737-2.434-16.697-9.499-24.401-17.318C110.249 91.543 95.725 76.8 64 76.8Z"/></svg>
</div>

### Tailwind

<p data-id="h3-tailwind">
<a href="https://tailwindcss.com/docs/installation">Tailwind CLI</a> enables a responsive, utility-first CSS framework for creating maintainable CSS at scale without the need for any CSS preprocessors like Sass, which is configured to run from an npx script to avoid needing any node_module dependencies.
</p>

<div data-id="icon-vue">
    <svg class="mx-auto block mt-8 w-20 h-20" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><path fill="#41b883" d="M24.4 3.925H30l-14 24.15L2 3.925h10.71l3.29 5.6l3.22-5.6Z"/><path fill="#41b883" d="m2 3.925l14 24.15l14-24.15h-5.6L16 18.415L7.53 3.925Z"/><path fill="#35495e" d="M7.53 3.925L16 18.485l8.4-14.56h-5.18L16 9.525l-3.29-5.6Z"/></svg>
</div>

### Vue 3

[Vue](https://vuejs.org/guide/introduction.html) is a popular Progressive JavaScript Framework that makes it easy to create interactive Reactive Components whose [Composition API](https://vuejs.org/api/composition-api-setup.html) offers a nice development model without requiring any pre-processors like JSX.

Where creating a component is as simple as:

```js
const Hello = {
    template: `<b>Hello, {{name}}!</b>`,
    props: { name:String }
}
```

<div data-id="Hello" class="text-center">
    <hello id="hello" name="Vue 3" class="text-2xl py-4"></hello>
</div>

Or a simple reactive example:

```js
import { ref } from "vue"

const Counter = {
    template: `<b @click="count++">Counter {{count}}</b>`,
    setup() {
        let count = ref(1)
        return { count }
    }
}
```

<div data-id="Counter" class="text-center">
    <counter class="text-2xl py-4 select-none cursor-pointer"></counter>
</div>

These components can be mounted using the standard [Vue 3 mount](https://vuejs.org/api/application.html#app-mount) API, but to 
make it easier we've added additional APIs for declaratively mounting components to pages using the `data-component` and `data-props`
attributes, especially useful for embedding Vue components in Markdown content, e.g:  

```html
<div data-component="Hello" data-props="{ name: 'Vue 3' }"></div>
```

Alternatively they can be programmatically added using the custom `mount` method in `api.mjs`:

```js
import { mount } from "/mjs/api.mjs"
mount('#counter', Counter)
```

<div></div>

Both methods create components with access to all your Shared Components and any 3rd Party Plugins which
we can preview in this example that uses **@servicestack/vue's** [PrimaryButton ](/vue/gallery/navigation#primarybutton)
and [ModalDialog](/vue/modals) components:

<div></div>
<div></div>

```js
const Plugin = {
    template:`<div>
        <PrimaryButton @click="show=true">Open Modal</PrimaryButton>
        <ModalDialog v-if="show" @done="show=false">
            <div class="p-8">Hello @servicestack/vue!</div>
        </ModalDialog>
    </div>`,
    setup() {
        const show = ref(false)
        return { show }
    }
}
```

<div></div>
<div></div>

<div data-id="Plugin" class="text-center not-prose">
    <plugin class="text-center text-2xl py-4"></plugin>
</div>

<h3>Vue.js Tailwind Components Library</h3>

<p data-id="intro-servicestack-vue"><a href="https://github.com/ServiceStack/servicestack-vue">@servicestack/vue</a> is our growing Vue 3 Tailwind component library with a number of rich Tailwind components useful in .NET Web Apps, including DataGrids, Auto Forms and Input Components with integrated contextual validation binding.</p>

<vue-component-gallery data-id="VueComponentGallery"></vue-component-gallery>

<div data-id="yt-YIa0w6whe2U" class="pb-8">
    <p class="mx-auto my-4 text-xl text-gray-500 text-center">For a quick preview of the fast dev workflow of using these components in a Razor Pages App, checkout:</p>
    <div class="flex justify-center">
        <lite-youtube class="w-full mx-4 my-4" width="560" height="315" videoid="YIa0w6whe2U" style="background-image: url('https://img.youtube.com/vi/YIa0w6whe2U/maxresdefault.jpg')"></lite-youtube>
    </div>
</div>

**@servicestack/vue** is our cornerstone library for enabling a highly productive dev model across our [Vue.js Tailwind Project templates](/templates/vue) that we'll be continuing to invest in to build a richer component library unlocking greater productivity - watch this space!

### @servicestack/client

[@servicestack/client](/javascript-client) is our generic JS/TypeScript client library
which enables a terse, typed API for using your App's typed DTOs from the built-in 
[JavaScript ES6 Classes](/javascript-add-servicestack-reference) support to enable an effortless 
end-to-end Typed development model for calling your APIs **without any build steps**, e.g:

```html
<input type="text" id="txtName">
<div id="result"></div>

<script type="module">
import { JsonServiceClient, $1, on } from '@servicestack/client'
import { Hello } from '/types/mjs'

on('#txtName', {
    async keyup(el) {
        const client = new JsonServiceClient()
        const api = await client.api(new Hello({ name:el.target.value }))
        $1('#result').innerHTML = api.response.result
    }
})
</script>
```

For better IDE intelli-sense during development, save the annotated Typed DTOs to disk with:

:::sh
npm run dtos
:::

That can be referenced instead to unlock your IDE's static analysis type-checking and intelli-sense benefits during development:

```js
import { Hello } from '/js/dtos.mjs'
client.api(new Hello({ name }))
```

You'll typically use all these libraries in your **API-enabled** components as seen in the 
[HelloApi.mjs](https://github.com/NetCoreTemplates/vue-mjs/blob/main/MyApp/wwwroot/mjs/components/HelloApi.mjs)
component on the [home page](https://vue-mjs.web-templates.io) which calls its [Hello API](https://vue-mjs.web-templates.io/ui/Hello) on each key press:

```js
import { ref } from "vue"
import { useClient } from "@servicestack/vue"
import { Hello } from "../dtos.mjs"

export default {
    template:/*html*/`<div class="flex flex-wrap justify-center">
        <TextInput v-model="name" @keyup="update" />
        <div class="ml-3 mt-2 text-lg">{{ result }}</div>
    </div>`,
    props:['value'],
    setup(props) {
        let name = ref(props.value)
        let result = ref('')
        let client = useClient()

        async function update() {
            let api = await client.api(new Hello({ name }))
            if (api.succeeded) {
                result.value = api.response.result
            }
        }
        update()

        return { name, update, result }
    }
}
```

We'll also go through and explain other features used in this component:

#### `/*html*/`

Although [not needed in Rider](https://vue-mjs.web-templates.io/blog/rider) (which can automatically infer HTML in strings), the `/*html*/` type hint is used to instruct tooling like the [es6-string-html](https://marketplace.visualstudio.com/items?itemName=Tobermory.es6-string-html)
VS Code extension to provide syntax highlighting and an enhanced authoring experience for HTML content in strings. 

### useClient

[useClient()](/vue/use-client) provides managed APIs around the `JsonServiceClient` instance, registered in Vue App's with:

```js
let client = new JsonServiceClient()
app.provide('client', client)
```

Which maintains contextual information around your API calls like **loading** and **error** states, used by `@servicestack/vue` components to 
enable its auto validation binding. Other functionality includes:

```js
let { 
    api,            // Send a typed API request and return results in an ApiResult<TResponse>
    apiVoid,        // Send a typed API request and return empty response in a void ApiResult
    apiForm,        // Send a FormData API request and return results in an ApiResult<TResponse>
    apiFormVoid,    // Send a FormData API request and return empty response in a void ApiResult
    loading,        // Maintain loading state whilst API Request is in transit
    error,          // Maintain API Error response in reactive Ref<ResponseStatus>
    setError,       // Set API error state with summary or field validation error
    addFieldError,  // Add field error to API error state
    unRefs          // Returns a dto with all Refs unwrapped
} = useClient()
```

#### setError

`setError` can be used to populate client-side validation errors which the 
[SignUp.mjs](https://github.com/NetCoreTemplates/vue-mjs/blob/main/MyApp/wwwroot/Pages/SignUp.mjs)
component uses to report an invalid submissions when passwords don't match:

```js
async function onSubmit() {
    if (password.value !== confirmPassword.value) {
        setError({ fieldName:'confirmPassword', message:'Passwords do not match' })
        return
    }
    //...
}
```

### Form Validation

All `@servicestack/vue` Input Components support contextual validation binding that's typically populated from API
[Error Response DTOs](/error-handling) but can also be populated from client-side validation
as done above.

#### Explicit Error Handling

This populated `ResponseStatus` DTO can either be manually passed into each component's **status** property as done in [/TodoMvc](https://vue-mjs.web-templates.io/TodoMvc):

```html
<template id="TodoMvc-template">
    <div class="mb-3">
        <text-input :status="store.error" id="text" label="" placeholder="What needs to be done?"
                    v-model="store.newTodo" v-on:keyup.enter.stop="store.addTodo()"></text-input>
    </div>
    <!-- ... -->
</template>
```

Where if you try adding an empty Todo the `CreateTodo` API will fail and populate its `store.error` reactive property with the 
APIs Error Response DTO which the `<TextInput />` component checks to display any field validation errors adjacent to the HTML Input
with matching `id` fields:

```js
let store = {
    /** @type {Todo[]} */
    todos: [],
    newTodo:'',
    error:null,
    async addTodo() {
        this.todos.push(new Todo({ text:this.newTodo }))
        let api = await client.api(new CreateTodo({ text:this.newTodo }))
        if (api.succeeded)
            this.newTodo = ''
        else 
            this.error = api.error
    },
    //...
}
```

#### Implicit Error Handling

More often you'll want to take advantage of the implicit validation support in `useClient()` which makes its state available to child
components, alleviating the need to explicitly pass it in each component as seen in razor tailwind's
[Contacts.mjs](https://github.com/NetCoreTemplates/razor/blob/net6/MyApp/wwwroot/Pages/Contacts.mjs) `Edit` component for its
Contacts page which doesn't do any manual error handling:

```js
const Edit = {
    template:/*html*/`<SlideOver @done="close" title="Edit Contact">
    <form @submit.prevent="submit">
      <input type="submit" class="hidden">
      <fieldset>
        <ErrorSummary except="title,name,color,filmGenres,age,agree" class="mb-4" />
        <div class="grid grid-cols-6 gap-6">
          <div class="col-span-6 sm:col-span-3">
            <SelectInput id="title" v-model="request.title" :options="enumOptions('Title')" />
          </div>
          <div class="col-span-6 sm:col-span-3">
            <TextInput id="name" v-model="request.name" required placeholder="Contact Name" />
          </div>
          <div class="col-span-6 sm:col-span-3">
            <SelectInput id="color" v-model="request.color" :options="colorOptions" />
          </div>
          <div class="col-span-6 sm:col-span-3">
            <SelectInput id="favoriteGenre" v-model="request.favoriteGenre" :options="enumOptions('FilmGenre')" />
          </div>
          <div class="col-span-6 sm:col-span-3">
            <TextInput type="number" id="age" v-model="request.age" />
          </div>
        </div>
      </fieldset>
    </form>
    <template #footer>
      <div class="flex justify-between space-x-3">
        <div><ConfirmDelete @delete="onDelete">Delete</ConfirmDelete></div>
        <div><PrimaryButton @click="submit">Update Contact</PrimaryButton></div>
      </div>
    </template>
  </SlideOver>`,
    props:['contact'],
    emits:['done'],
    setup(props, { emit }) {
        const client = useClient()
        const request = ref(new UpdateContact(props.contact))
        const colorOptions = propertyOptions(getProperty('UpdateContact','Color'))

        async function submit() {
            const api = await client.api(request.value)
            if (api.succeeded) close()
        }

        async function onDelete () {
            const api = await client.apiVoid(new DeleteContact({ id:props.id }))
            if (api.succeeded) close()
        }

        const close = () => emit('done')

        return { request, enumOptions, colorOptions, submit, onDelete, close }
    }
}
```

Effectively making form validation binding a transparent detail where all `@servicestack/vue` 
Input Components are able to automatically apply contextual validation errors next to the fields they apply to: 

<div class="mx-auto max-w-screen-md block flex justify-center"><img class="p-4" src="/img/pages/scripts/edit-contact-validation.png"></div>

### AutoForm Components

We can elevate our productivity even further with
[Auto Form Components](/vue/autoform) that can automatically generate an
instant API-enabled form with validation binding by just specifying the Request DTO you want to create the form of, e.g:

```html
<AutoCreateForm type="CreateBooking" formStyle="card" />
```

<div data-id="AutoCreateForm" class="not-prose max-w-3xl"><AutoCreateForm type="CreateBooking" formStyle="card" /></div>

The AutoForm components are powered by your [App Metadata](/vue/use-metadata) which allows creating 
highly customized UIs from [declarative C# attributes](/locode/declarative) whose customizations are
reused across all ServiceStack Auto UIs, including:

 - [API Explorer](/api-explorer) 
 - [Locode](/locode/)
 - [Blazor Tailwind Components](/templates/blazor-components)

### Form Input Components

In addition to including Tailwind versions of the standard [HTML Form Inputs](/vue/form-inputs) controls to create beautiful Tailwind Forms,
it also contains a variety of integrated high-level components:

### FileInput

**[FileInput component](/vue/fileinput)** beautifies the browsers default HTML file Input, supporting both Single file uploads: 

```html
<FileInput id="profileUrl" label="Single File Upload" v-model="contact.profileUrl" />
```

<a href="/vue/gallery/fileinput"><img class="max-w-[516px]" src="/img/pages/release-notes/v6.6/file-input-single.png"></a>

and Multiple File Uploads:

```html
<FileInput id="profileUrls" label="Multiple File Uploads" multiple :files="contact.files" />
```

<a href="/vue/gallery/fileinput"><img class="max-w-[374px]" src="/img/pages/release-notes/v6.6/file-input-multiple.png"></a>

#### Invoking APIs containing uploaded files

When uploading files, you'll need to submit API requests using the `apiForm` or `apiFormVoid` methods to send
a populated `FormData` instead of a Request DTO, e.g:

```html
<form @submit.prevent="submit">
    <FileInput id="profileUrls" label="Multiple File Uploads" multiple :files="files" />
    <PrimaryButton>Save</PrimaryButton>
</form>

<script setup lang="ts">
import { useClient } from "@servicestack/vue"
import { CreateContact } from "/mjs/dtos.mjs"

const client = useClient()
async function submit(e:Event) {
    const form = e.target as HTMLFormElement
    const api = await client.apiForm(new CreateContact(), new FormData(form))
    if (api.succeeded) {
        //...
    }
}
</script>
```

#### Integrates with Managed File Uploads

Using [Managed File Uploads](/locode/files-overview) is a productive solution for easily managing file uploads where you can declaratively specify
which location uploaded files should be written to, e.g:

```csharp
public class UpdateContact : IPatchDb<Contact>, IReturn<Contact>
{
    public int Id { get; set; }
    [ValidateNotEmpty]
    public string? FirstName { get; set; }
    [ValidateNotEmpty]
    public string? LastName { get; set; }
    [Input(Type = "file"), UploadTo("profiles")]
    public string? ProfileUrl { get; set; }
    public int? SalaryExpectation { get; set; }
    [ValidateNotEmpty]
    public string? JobType { get; set; }
    public int? AvailabilityWeeks { get; set; }
    public EmploymentType? PreferredWorkType { get; set; }
    public string? PreferredLocation { get; set; }
    [ValidateNotEmpty]
    public string? Email { get; set; }
    public string? Phone { get; set; }
    [Input(Type = "tag"), FieldCss(Field = "col-span-12")]
    public List<string>? Skills { get; set; }
    [Input(Type = "textarea")]
    [FieldCss(Field = "col-span-12 text-center", Input = "h-48", Label= "text-xl text-indigo-700")]
    public string? About { get; set; }
}
```

This metadata information is also available to [AutoForm components](/vue/autoform) which supports invoking APIs with uploaded files:

```html
<AutoEditForm type="UpdateContact" v-model="contact" formStyle="card" />
```

<a href="/vue/gallery/form-inputs#updatecontact"><img class="max-w-[778px]" src="/img/pages/release-notes/v6.6/autoeditform-updatecontact.png"></a>

### TagInput

**[TagInput component](/vue/gallery/taginput)** provides a user friendly control for managing a free-form `List<string>` tags or symbols
which is also supported in declarative Auto Forms using the `[Input(Type="tag")]` attribute as seen in the 
**UpdateContact** example above using the [AutoForm components](/vue/autoform).

Alternatively `<TagInput>` can be used in Custom Forms directly by binding to a `List<string>` or `string[]` model:

```html
<form @submit.prevent="submit">
    <div class="shadow sm:rounded-md bg-white dark:bg-black">
        <div class="relative px-4 py-5 sm:p-6">
            <fieldset>
                <legend class="text-base font-medium text-gray-900 dark:text-gray-100 text-center mb-4">
                    TagInput Examples
                </legend>
                <ErrorSummary :except="visibleFields" />
                <div class="grid grid-cols-12 gap-6">
                    <div class="col-span-6">
                        <TextInput v-model="request.firstName" />
                    </div>
                    <div class="col-span-6">
                        <TextInput v-model="request.lastName" />
                    </div>
                    <div class="col-span-12">
                        <TagInput v-model="request.skills" label="Technology Skills" />
                    </div>
                </div>
            </fieldset>
        </div>
        <div class="mt-4 px-4 py-3 bg-gray-50 dark:bg-gray-900 sm:px-6 flex flex-wrap justify-between">
            <div></div>
            <div class="flex justify-end">
                <SecondaryButton class="mr-4">Cancel</SecondaryButton>
                <PrimaryButton type="submit">Submit</PrimaryButton>
            </div>
        </div>
    </div>
</form>
```

<a href="/vue/gallery/taginput"><img class="max-w-[778px]" src="/img/pages/release-notes/v6.6/taginput-examples.png"></a>

### Autocomplete

**[Autocomplete component](/vue/gallery/autocomplete)** provides a user friendly Input for being able to search and quickly select items
with support for partial items view and infinite scrolling.

<a href="/vue/gallery/autocomplete"><img class="max-w-[571px]" src="/img/pages/release-notes/v6.6/autocomplete-examples.png"></a>

### useAuth

Your Vue.js code can access Authenticated Users using [useAuth()](/vue/use-auth)
which can also be populated without the overhead of an Ajax request by embedding the response of the built-in
[Authenticate API](https://vue-mjs.web-templates.io/ui/Authenticate?tab=details) inside `_Layout.cshtml` with:

```html
<script type="module">
import { useAuth } from "@@servicestack/vue"
const { signIn } = useAuth()
signIn(@await Html.ApiAsJsonAsync(new Authenticate()))
</script>
```

Where it enables access to the below [useAuth()](/vue/use-auth) utils for inspecting the 
current authenticated user:  

```js
const { 
    signIn,           // Sign In the currently Authenticated User
    signOut,          // Sign Out currently Authenticated User
    user,             // Access Authenticated User info in a reactive Ref<AuthenticateResponse>
    isAuthenticated,  // Check if the current user is Authenticated in a reactive Ref<boolean>
    hasRole,          // Check if the Authenticated User has a specific role
    hasPermission,    // Check if the Authenticated User has a specific permission
    isAdmin           // Check if the Authenticated User has the Admin role
} = useAuth()
```

This is used in [Bookings.mjs](https://github.com/NetCoreTemplates/vue-mjs/blob/main/MyApp/wwwroot/Pages/Bookings.mjs)
to control whether the `<AutoEditForm>` component should enable its delete functionality:

```js
export default {
    template/*html*/:`
    <AutoEditForm type="UpdateBooking" :deleteType="canDelete ? 'DeleteBooking' : null" />
    `,
    setup(props) {
        const { hasRole } = useAuth()
        const canDelete = computed(() => hasRole('Manager'))
        return { canDelete }
    }
}
```

#### [JSDoc](https://jsdoc.app)

We get great value from using [TypeScript](https://www.typescriptlang.org) to maintain our libraries typed code bases, however it 
does mandate using an external tool to convert it to valid JS before it can be run, something the new Razor Vue.js templates expressly avoids. 

Instead it adds JSDoc type annotations to code where it adds value, which at the cost of slightly more verbose syntax enables much of the 
same static analysis and intelli-sense benefits of TypeScript, but without needing any tools to convert it to valid JavaScript, e.g: 

```js
/** @param {KeyboardEvent} e */
function validateSafeName(e) {
    if (e.key.match(/[\W]+/g)) {
        e.preventDefault()
        return false
    }
}
```

#### TypeScript static analysis during development

Whilst the code-base doesn't use TypeScript syntax in its code base directly, it still benefits from TypeScript's language services in IDEs for the included libraries from the TypeScript definitions included in `/lib/typings`, downloaded in 
[postinstall.js](https://github.com/NetCoreTemplates/vue-mjs/blob/main/MyApp/postinstall.js) after **npm install**.

### Import Maps

[Import Maps](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script/type/importmap) is a useful browser feature that allows
specifying optimal names for modules, that can be used to map package names to the implementation it should use, e.g:

```csharp
@Html.StaticImportMap(new() {
    ["vue"]                  = "/lib/mjs/vue.mjs",
    ["@servicestack/client"] = "/lib/mjs/servicestack-client.mjs",
    ["@servicestack/vue"]    = "/lib/mjs/servicestack-vue.mjs",
})
```

Where they can be freely maintained in one place without needing to update any source code references.
This allows source code to be able to import from the package name instead of its physical location:

```js
import { ref } from "vue"
import { useClient } from "@servicestack/vue"
import { JsonApiClient, $1, on } from "@servicestack/client"
```

It's a great solution for specifying using local unminified debug builds during **Development**, and more optimal CDN hosted 
production builds when running in **Production**, alleviating the need to rely on complex build tools to perform this code transformation for us:

```csharp
@Html.ImportMap(new()
{
    ["vue"]                  = ("/lib/mjs/vue.mjs",                 "https://unpkg.com/vue@3/dist/vue.esm-browser.prod.js"),
    ["@servicestack/client"] = ("/lib/mjs/servicestack-client.mjs", "https://unpkg.com/@servicestack/client@2/dist/servicestack-client.min.mjs"),
    ["@servicestack/vue"]    = ("/lib/mjs/servicestack-vue.mjs",    "https://unpkg.com/@servicestack/vue@3/dist/servicestack-vue.min.mjs")
})
```

> Note: Specifying exact versions of each dependency improves initial load times by eliminating latency from redirects. 

Or if you don't want to reference any external dependencies, have the ImportMap reference local minified production builds instead:

```csharp
@Html.ImportMap(new()
{
    ["vue"]                  = ("/lib/mjs/vue.mjs",                 "/lib/mjs/vue.min.mjs"),
    ["@servicestack/client"] = ("/lib/mjs/servicestack-client.mjs", "/lib/mjs/servicestack-client.min.mjs"),
    ["@servicestack/vue"]    = ("/lib/mjs/servicestack-vue.mjs",    "/lib/mjs/servicestack-vue.min.mjs")
})
```

#### Polyfill for Safari

Unfortunately Safari is the last modern browser to [support import maps](https://caniuse.com/import-maps) which is only now in
Technical Preview. Luckily this feature can be polyfilled with the pre-configured [ES Module Shims](https://github.com/guybedford/es-module-shims):

```html
@if (Context.Request.Headers.UserAgent.Any(x => x.Contains("Safari") && !x.Contains("Chrome")))
{
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.6.3/dist/es-module-shims.js"></script>
}
```

### Fast Component Loading

SPAs are notorious for being slow to load due to needing to download large blobs of JavaScript bundles that it needs to initialize
with their JS framework to mount their App component before it starts fetching the data from the server it needs to render its components. 

A complex solution to this problem is to server render the initial HTML content then re-render it again on the client after the page loads. 
A simpler solution is to avoid unnecessary ajax calls by embedding the JSON data the component needs in the page that loads it, which is what [/TodosMvc](https://vue-mjs.web-templates.io/TodoMvc) does to load its initial list of todos using the [Service Gateway](/service-gateway) to invoke APIs in process and embed its JSON response with:

```html
<script>todos = @await ApiResultsAsJsonAsync(new QueryTodos())</script>
<script type="module">
import TodoMvc from "/Pages/TodoMvc.mjs"
import { mount } from "/mjs/app.mjs"
mount('#todomvc', TodoMvc, { todos })
</script>
```

Where `ApiResultsAsJsonAsync` is a simplified helper that uses the [Gateway](/service-gateway) to call your API and returns its unencoded JSON response:

```csharp
(await Gateway.ApiAsync(new QueryTodos())).Response?.Results.AsRawJson();
```

The result of which should render the List of Todos instantly when the page loads since it doesn't need to perform any additional Ajax requests
after the component is loaded.

### Fast Page Loading

We can get SPA-like page loading performance using htmx's [Boosting](https://htmx.org/docs/#boosting) feature which avoids full page reloads
by converting all anchor tags to use Ajax to load page content into the page body, improving performance from avoiding needing to reload 
scripts and CSS in `<head>`

This is used in [Header.cshtml](https://github.com/NetCoreTemplates/vue-mjs/blob/main/MyApp/Pages/Shared/Header.cshtml) to **boost** all
main navigation links:

```html
<nav hx-boost="true">
    <ul>
        <li><a href="/Blog">Blog</a></li>
    </ul>
</nav>
```

htmlx has lots of useful [real world examples](https://htmx.org/examples/) that can be activated with declarative attributes, 
another feature the **vue-mjs** template uses is the [class-tools](https://htmx.org/extensions/class-tools/) extension to hide elements from 
appearing until after the page is loaded:

```html
<div id="signin"></div>
<div class="hidden mt-5 flex justify-center" classes="remove hidden:load">
    @Html.SrcPage("SignIn.mjs")
</div>
```

Which reduces UI yank from not showing server rendered content before JS components have loaded. 

### Fast pre-rendered static generated Razor Pages

[![](https://images.unsplash.com/photo-1522526886914-6e8d4fd91399?crop=entropy&fit=crop&h=500&w=1000)](https://vue-mjs.web-templates.io/blog/prerendering)

Whilst not required, the **vue-mjs** template also includes support for pre-rendering static content from Razor Pages.

Prerendering static content is a popular technique used by JAMStack Apps to improve the performance, reliability and scalability of Web Apps that's able to save unnecessary computation at runtime by generating static content at deployment which can be optionally hosted from a CDN for even greater performance.

As such we thought it a valuable technique to include the **vue-mjs** template to show how it can be easily achieved within a Razor Pages App. Since prerendered content is only updated at deployment, it's primarily only useful for static content like [this Blog](https://vue-mjs.web-templates.io/blog/prerendering) which is powered by the static markdown content in [_blog/posts](https://github.com/NetCoreTemplates/vue-mjs/tree/main/MyApp/wwwroot/_blog/posts) whose content is prerendered to  `/wwwroot/blog`.

For those interested in utilizing this optimization we've published details on how this works in the 
**[Prerendering Razor Pages](https://vue-mjs.web-templates.io/blog/prerendering)** blog post.

## Develop using JetBrains Rider

<a href="https://www.jetbrains.com/rider/">
<img src="/img/pages/svg/rider.svg" class="sm:float-left mr-8 w-24 h-24" style="margin-top:0"></a>

Given it's best-of-class support for Web Development we recommend using JetBrains Rider for any kind of JS or TypeScript development. If you're 
using Rider checkout the **[Develop using JetBrains Rider](https://vue-mjs.web-templates.io/blog/rider)** blog post for an optimal setup for 
Vue.js and Tailwind Web Apps.

## Develop using Visual Studio

<a href="https://visualstudio.microsoft.com/" title="VS Code" class="sm:float-left mr-8">
    <svg class="w-24 h-24" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 254"><defs><linearGradient id="logosVisualStudioCode0" x1="50%" x2="50%" y1="0%" y2="100%"><stop offset="0%" stop-color="#FFF"></stop><stop offset="100%" stop-color="#FFF" stop-opacity="0"></stop></linearGradient><path id="logosVisualStudioCode1" d="M180.828 252.605a15.872 15.872 0 0 0 12.65-.486l52.501-25.262a15.94 15.94 0 0 0 9.025-14.364V41.197a15.939 15.939 0 0 0-9.025-14.363l-52.5-25.263a15.877 15.877 0 0 0-18.115 3.084L74.857 96.35l-43.78-33.232a10.614 10.614 0 0 0-13.56.603L3.476 76.494c-4.63 4.211-4.635 11.495-.012 15.713l37.967 34.638l-37.967 34.637c-4.623 4.219-4.618 11.502.012 15.714l14.041 12.772a10.614 10.614 0 0 0 13.56.604l43.78-33.233l100.507 91.695a15.853 15.853 0 0 0 5.464 3.571Zm10.464-183.649l-76.262 57.889l76.262 57.888V68.956Z"></path></defs><mask id="logosVisualStudioCode2" fill="#fff"><use href="#logosVisualStudioCode1"></use></mask><path fill="#0065A9" d="M246.135 26.873L193.593 1.575a15.885 15.885 0 0 0-18.123 3.08L3.466 161.482c-4.626 4.219-4.62 11.502.012 15.714l14.05 12.772a10.625 10.625 0 0 0 13.569.604L238.229 33.436c6.949-5.271 16.93-.315 16.93 8.407v-.61a15.938 15.938 0 0 0-9.024-14.36Z" mask="url(#logosVisualStudioCode2)"></path><path fill="#007ACC" d="m246.135 226.816l-52.542 25.298a15.887 15.887 0 0 1-18.123-3.08L3.466 92.207c-4.626-4.218-4.62-11.502.012-15.713l14.05-12.773a10.625 10.625 0 0 1 13.569-.603l207.132 157.135c6.949 5.271 16.93.315 16.93-8.408v.611a15.939 15.939 0 0 1-9.024 14.36Z" mask="url(#logosVisualStudioCode2)"></path><path fill="#1F9CF0" d="M193.428 252.134a15.892 15.892 0 0 1-18.125-3.083c5.881 5.88 15.938 1.715 15.938-6.603V11.273c0-8.318-10.057-12.483-15.938-6.602a15.892 15.892 0 0 1 18.125-3.084l52.533 25.263a15.937 15.937 0 0 1 9.03 14.363V212.51c0 6.125-3.51 11.709-9.03 14.363l-52.533 25.262Z" mask="url(#logosVisualStudioCode2)"></path><path fill="url(#logosVisualStudioCode0)" fill-opacity=".25" d="M180.828 252.605a15.874 15.874 0 0 0 12.65-.486l52.5-25.263a15.938 15.938 0 0 0 9.026-14.363V41.197a15.939 15.939 0 0 0-9.025-14.363L193.477 1.57a15.877 15.877 0 0 0-18.114 3.084L74.857 96.35l-43.78-33.232a10.614 10.614 0 0 0-13.56.603L3.476 76.494c-4.63 4.211-4.635 11.495-.012 15.713l37.967 34.638l-37.967 34.637c-4.623 4.219-4.618 11.502.012 15.714l14.041 12.772a10.614 10.614 0 0 0 13.56.604l43.78-33.233l100.506 91.695a15.857 15.857 0 0 0 5.465 3.571Zm10.464-183.65l-76.262 57.89l76.262 57.888V68.956Z" mask="url(#logosVisualStudioCode2)"></path></svg>
</a>

If you prefer using VS .NET we recommend using VS Code for all your Apps JS front-end development and optionally VS .NET for the back-end C#/.NET development of large .NET Projects. If using VS checkout **[Develop using Visual Studio](https://vue-mjs.web-templates.io/blog/vs)**
blog post for an optimal setup for utilizing Vue.js composition API and Tailwind.

<div class="clear-both"></div>


## Feedback Welcome!

We hope you enjoy these exciting new templates in this release, as always if you have any questions or feedback in this release please let us know in 
[ServiceStack/Discuss](https://github.com/ServiceStack/Discuss/discussions) GitHub Discussions or the [Customer Forums](https://forums.servicestack.net/).

## @servicestack/client now dependency-free

Now that [fetch has finally landed](https://blog.logrocket.com/fetch-api-node-js/) in Node.js v18+ LTS we've gone ahead and removed all polyfills
to make **@servicestack/client** dependency-free in its latest major **v2.x** version!

This should have no effect when using [JsonServiceClient](/javascript-client) in Browsers which uses its native `fetch()` or from Node.js v18+ that now has native `fetch` support as well. 

### ServerEventsClient in Node.js

But Node.js projects using [ServerEventsClient](/typescript-server-events-client) (e.g. in tests) now require a polyfill:

:::sh
npm install eventsource
:::

Then polyfill with:

```ts
globalThis.EventSource = require("eventsource")
```

### JsonServiceClient in Node.js < v18

Older Node.js runtimes using `JsonServiceClient` can continue using the existing **v1.x** version or polyfill `fetch` with:

:::sh
npm install cross-fetch
:::

Then polyfill with:

```js
require('cross-fetch/polyfill')
```


## MSVR 76883

We've received a vulnerability report from the Microsoft Vulnerability Research team last week who found a potential vulnerability in ServiceStack.Redis (.NET Framework) if an attack is able to write a malicious string into a Redis Server and trick an Application into reading it back into a C# DTO with a nested complex type containing a late-bound `object` property, the report reads:

> This attack requires a malicious string to be written to the Redis cache and then read back as an object. The most likely attack pattern here is going to involve some sort of injection attack where an application can be tricked into writing untrusted data to a Redis cache that it will later read back.

Unfortunately it's another example of exploiting the same issue that's plagued .NET Serializers for years where the existence of dangerous classes in .NET Framework where setting a public instance property can cause an App to load and execute code in an external .dll requires all .NET Serializers supporting dynamic payloads to maintain a [Runtime Type Whitelist](/json-format#late-bound-object-and-interface-runtime-types) of Types that are allowed to be dynamically instantiated in `object` properties.

This vulnerability found a nested structure code path which skipped the whitelist checks which has since been resolved in this release. 

As a result existing code deserializing non-whitelisted unverified types in late-bound `object` properties will start throwing `NotSupportedException`, to resolve, Types needs to be allowed in the [Runtime Type Whitelist](/json-format#runtime-type-whitelist) which by default can be annotated with:

```csharp
[Serializable]
[DataContract]
[RuntimeSerializable]
```

Or implement one of these interfaces:

```csharp
ISerializable
IConvertible
IRuntimeSerializable
IReturn<T>
IReturnVoid
IMeta
IVerb                 // IGet, IPost, IPut, IPatch, etc  
ICrud                 // ICreateDb`1, IUpdateDb`1, etc
IAuthTokens
IHasResponseStatus
IHasId<T>
```

Effectively it looks to allow any serializable models and DTOs it can find by looking at all available heuristics.
